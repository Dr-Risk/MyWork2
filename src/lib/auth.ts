
'use server';
/**
 * @fileoverview Mock Authentication & User Management for PixelForge Nexus
 *
 * @description
 * This file simulates a backend authentication system for the game development
 * project management tool. It manages user data in-memory with roles tailored
 * for this purpose: 'admin', 'project-lead', and 'developer'.
 *
 * =============================================================================
 * SECURITY NOTICE (OWASP Top 10 & NIST Compliance)
 * =============================================================================
 * This is a MOCK system and is NOT secure for production use. It includes
 * comments below that highlight key security principles from OWASP and NIST
 * that would be implemented in a real-world application.
 */

import { z } from "zod";
import fs from 'fs';
import path from 'path';

// Path to the mock database file
const dbPath = path.join(process.cwd(), 'src', 'lib', 'users.json');

/**
 * @interface UserProfile
 * @description Defines the structure for a user's public profile. This data is
 * considered "safe" to send to the client-side and display in the UI.
 */
export interface UserProfile {
    username: string;
    role: 'admin' | 'project-lead' | 'developer';
    name: string;
    initials: string;
    email: string;
}

/**
 * @interface UserWithPassword
 * @description Extends the public profile with sensitive, internal-only data for the
 * backend. This data should NEVER be sent to the client.
 */
interface UserWithPassword extends UserProfile {
    /**
     * [SECURITY] Password Storage (OWASP A02 - Cryptographic Failures)
     * In a real application, this would be a secure, salted hash generated by a
     * strong, adaptive hashing algorithm like Argon2 or bcrypt. Storing passwords
     * as plain text or simple hashes (like SHA-256) is insecure.
     */
    passwordHash: string;
    
    /**
     * [SECURITY] Brute Force Protection (OWASP A07 - Auth Failures)
     * Tracks failed login attempts to implement account lockout mechanisms.
     */
    loginAttempts: number;
    
    /**
     * [SECURITY] Account Lockout (OWASP A07 - Auth Failures)
     * A flag to lock an account after too many failed login attempts.
     */
    isLocked: boolean;
    
    /**
     * [SECURITY] Password Expiration Policy (NIST SP 800-63B)
     * Stores the date of the last password change to enforce rotation policies.
     */
    passwordLastChanged: string;
}

/**
 * Reads all users from the users.json file.
 * @returns A promise that resolves to the user data object.
 */
const readUsersFromFile = async (): Promise<{ [key: string]: UserWithPassword }> => {
    try {
        if (!fs.existsSync(dbPath)) {
            const initialUsers = getInitialUsers();
            await writeUsersToFile(initialUsers);
            return initialUsers;
        }
        const data = await fs.promises.readFile(dbPath, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error('Error reading users from file, falling back to initial data.', error);
        return getInitialUsers();
    }
};

/**
 * Writes the entire user object to the users.json file.
 * @param data The user data to write.
 */
const writeUsersToFile = async (data: { [key: string]: UserWithPassword }): Promise<void> => {
    try {
        await fs.promises.writeFile(dbPath, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('Error writing users to file.', error);
    }
};

/**
 * A private function that returns a fresh copy of the initial user data.
 * This is the single source of truth for initializing the mock database.
 */
function getInitialUsers(): { [key: string]: UserWithPassword } {
    return {
        'moqadri': {
            username: 'moqadri',
            passwordHash: 'DefaultPassword123_hashed', // Corresponds to 'DefaultPassword123'
            role: 'admin',
            name: 'Mo Qadri',
            initials: 'MQ',
            email: 'mo.qadri@example.com',
            loginAttempts: 0,
            isLocked: false,
            passwordLastChanged: new Date().toISOString(),
        }
    };
}


/**
 * [SECURITY] Input Validation (OWASP A03 - Injection)
 * Zod schema for validating new user creation data on the "server".
 * This ensures that all required fields are present and in the correct format
 * before any processing occurs.
 */
const CreateUserSchema = z.object({
  name: z.string().min(2),
  username: z.string().min(3),
  email: z.string().email(),
  password: z.string().min(8),
  role: z.enum(['project-lead', 'developer']),
});
type CreateUserInput = z.infer<typeof CreateUserSchema>;


/**
 * Creates a new user in the mock database.
 * @param userData The user data to create.
 * @returns A promise that resolves to a success or failure message.
 */
export const createUser = async (
  userData: CreateUserInput
): Promise<{ success: boolean; message:string }> => {
    const users = await readUsersFromFile();
    // Prevent username collisions.
    if (users[userData.username]) {
        return { success: false, message: "Username already exists." };
    }

    // Generate user initials from their full name.
    const initials = (userData.name.match(/\b\w/g) || []).join('').toUpperCase() || '??';

    users[userData.username] = {
        username: userData.username,
        passwordHash: `${userData.password}_hashed`, // MOCK HASHING
        role: userData.role, 
        name: userData.name,
        initials: initials,
        email: userData.email,
        loginAttempts: 0,
        isLocked: false,
        passwordLastChanged: new Date().toISOString(),
    };
    await writeUsersToFile(users);

    console.log(`User '${userData.username}' created in mock database.`);
    return { success: true, message: "User created successfully." };
};


/**
 * Simulates verifying a password against a stored hash.
 * @param password The plain text password.
 * @param hash The stored "hash".
 * @returns A promise that resolves to true if the password is correct.
 */
const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
    // In a real app, this would be: `await bcrypt.compare(password, hash)`
    return `${password}_hashed` === hash;
}

// The maximum number of failed login attempts before an account is locked.
const MAX_LOGIN_ATTEMPTS = 3;

// The type definition for the response of the credential check function.
export type AuthResponse = 
    | { status: 'success'; user: UserProfile }
    | { status: 'invalid'; message: string }
    | { status: 'locked'; message: string }
    | { status: 'expired'; message: string };

/**
 * [SECURITY] Input Validation (OWASP A03 - Injection)
 * A Zod schema to validate the shape and content of login credentials.
 * The regex for the username is a strict "allow-list" to prevent common
 * injection characters. This server-side validation is the primary defense.
 */
const LoginCredentialsSchema = z.object({
  username: z.string().regex(/^[a-zA-Z0-9_.-]+$/),
  password: z.string().min(8),
});


/**
 * Checks a user's credentials against the mock database.
 * @param username The user's username.
 * @param pass The user's password.
 * @returns A promise resolving to an AuthResponse object.
 */
export const checkCredentials = async (username: string, pass: string): Promise<AuthResponse> => {
  // 1. Validate input format.
  const validation = LoginCredentialsSchema.safeParse({ username, password: pass });
  if (!validation.success) {
    return { status: 'invalid', message: 'Invalid username or password.' };
  }
  
  const users = await readUsersFromFile();
  const user = users[username];

  // 2. Check if user exists.
  if (!user) {
    // [SECURITY] User Enumeration Prevention (OWASP A07)
    // Return a generic message to prevent attackers from guessing valid usernames.
    return { status: 'invalid', message: 'Invalid username or password.' };
  }

  // 3. Check if account is locked.
  if (user.isLocked) {
    return { status: 'locked', message: 'Your account is locked due to too many failed login attempts.' };
  }

  // 4. Verify password.
  const isPasswordCorrect = await verifyPassword(pass, user.passwordHash);

  if (!isPasswordCorrect) {
    // [SECURITY] Admin Account Protection
    // Do not increment login attempts or lock the account if the user is an admin.
    if (user.role !== 'admin') {
      user.loginAttempts++;
      if (user.loginAttempts >= MAX_LOGIN_ATTEMPTS) {
        user.isLocked = true;
      }
      await writeUsersToFile(users); // Save updated attempts/lock status.
    }
    return { status: 'invalid', message: 'Invalid username or password.' };
  }
  
  // 5. Check for password expiration, but only for non-admin users.
  const ninetyDaysAgo = new Date();
  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
  if (user.role !== 'admin' && new Date(user.passwordLastChanged) < ninetyDaysAgo) {
    return { status: 'expired', message: 'Your password has expired. Please change it to continue.' };
  }

  // 6. On success, reset login attempts and prepare the user profile to be returned.
  user.loginAttempts = 0;
  await writeUsersToFile(users);
  
  // [SECURITY] Data Minimization
  // Only return the non-sensitive UserProfile, not the internal UserWithPassword.
  const { passwordHash, loginAttempts, isLocked, passwordLastChanged, ...userProfile } = user;
  
  return { status: 'success', user: userProfile };
}

/**
 * A "sanitized" user type that omits the password hash, safe to use within the app.
 */
export type SanitizedUser = Omit<UserWithPassword, 'passwordHash'>;

/**
 * Retrieves a list of all users without their password hashes.
 */
export const getUsers = async (): Promise<SanitizedUser[]> => {
  const users = await readUsersFromFile();
  return Object.values(users).map(user => {
    const { passwordHash, ...sanitizedUser } = user;
    return sanitizedUser;
  });
};

/**
 * Retrieves a list of users who are developers or project leads.
 */
export const getDevelopers = async (): Promise<SanitizedUser[]> => {
  const allUsers = await getUsers();
  return allUsers.filter(u => u.role === 'developer' || u.role === 'project-lead');
}

/**
 * Updates a user's role.
 */
export const updateUserRole = async (
  username: string,
  newRole: 'project-lead' | 'developer'
): Promise<{ success: boolean; message: string }> => {
  const users = await readUsersFromFile();
  const user = users[username];

  if (!user) return { success: false, message: 'User not found.' };
  // [SECURITY] Access Control (OWASP A01 - Broken Access Control)
  // Prevent changing the role of the admin user.
  if (user.role === 'admin') return { success: false, message: 'Cannot change the role of an admin user.' };

  user.role = newRole;
  await writeUsersToFile(users);
  console.log(`User '${username}' role updated to '${newRole}' in mock database.`);
  return { success: true, message: 'User role updated successfully.' };
};


/**
 * Updates a user's profile information (name and email).
 */
export const updateUserProfile = async (
  username: string,
  data: { name: string; email: string }
): Promise<{ success: boolean; message: string; user?: UserProfile }> => {
  const users = await readUsersFromFile();
  const user = users[username];
  if (!user) return { success: false, message: 'User not found.' };

  user.name = data.name;
  user.email = data.email;
  user.initials = (data.name.match(/\b\w/g) || []).join('').toUpperCase() || '??';
  await writeUsersToFile(users);

  console.log(`User '${username}' profile updated in mock database.`);
  const { passwordHash, loginAttempts, isLocked, passwordLastChanged, ...userProfile } = user;
  return { success: true, message: 'Profile updated successfully.', user: userProfile };
};


/**
 * Updates a user's password after verifying their current one.
 */
export const updateUserPassword = async (
    username: string,
    currentPass: string,
    newPass: string
): Promise<{ success: boolean; message: string }> => {
    const users = await readUsersFromFile();
    const user = users[username];
    if (!user) return { success: false, message: "User not found." };

    // Users must provide their current password to change it.
    const isPasswordCorrect = await verifyPassword(currentPass, user.passwordHash);
    if (!isPasswordCorrect) return { success: false, message: "Incorrect current password." };

    user.passwordHash = `${newPass}_hashed`; // MOCK HASHING
    user.passwordLastChanged = new Date().toISOString(); 
    await writeUsersToFile(users);

    console.log(`User '${username}' password updated in mock database.`);
    return { success: true, message: "Password updated successfully." };
}

/**
 * Manually locks a user account.
 */
export const lockUserAccount = async (
  username: string
): Promise<{ success: boolean; message: string }> => {
  const users = await readUsersFromFile();
  const user = users[username];
  if (!user) return { success: false, message: 'User not found.' };
  // [SECURITY] Admin Backdoor Removal
  // The check to prevent admins from being locked has been updated to only apply here,
  // not in the main login flow, hardening the system.
  if (user.role === 'admin') return { success: false, message: 'Admin accounts cannot be locked.' };

  user.isLocked = true;
  await writeUsersToFile(users);
  console.log(`User account for '${username}' has been manually locked.`);
  return { success: true, message: 'User account locked successfully.' };
};

/**
 * Manually unlocks a user account and resets their login attempts.
 */
export const unlockUserAccount = async (
  username: string
): Promise<{ success: boolean; message: string }> => {
  const users = await readUsersFromFile();
  const user = users[username];
  if (!user) return { success: false, message: 'User not found.' };
  if (user.role === 'admin') return { success: false, message: 'Admin accounts cannot be locked.' };

  user.isLocked = false;
  user.loginAttempts = 0; 
  await writeUsersToFile(users);
  console.log(`User account for '${username}' has been unlocked.`);
  return { success: true, message: 'User account unlocked successfully.' };
};


/**
 * Permanently removes a user from the system.
 */
export const removeUser = async (
    username: string
): Promise<{ success: boolean; message: string }> => {
    const users = await readUsersFromFile();
    const user = users[username];
    if (!user) return { success: false, message: "User not found." };
    if (user.role === 'admin') return { success: false, message: "Cannot remove an admin account." };

    delete users[username];
    await writeUsersToFile(users);
    console.log(`User '${username}' removed from mock database.`);
    return { success: true, message: "User removed successfully." };
};
    